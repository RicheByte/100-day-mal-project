import os
import sys
import time
import subprocess
import hashlib
import pefile
import yara
import psutil
import requests
import json
import threading
import argparse
from scapy.all import sniff, IP, TCP, UDP
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import frida

# Configuration
MALWARE_PATH = "malware_sample.exe"  # Replace with your malware file path
YARA_RULES_PATH = "yara_rules.yar"   # Replace with your YARA rules file
VIRUSTOTAL_API_KEY = "your_virustotal_api_key"  # Replace with your VirusTotal API key
REPORT_FILE = "malware_analysis_report.txt"

def log_to_file(message):
    """Append a message to the report file."""
    with open(REPORT_FILE, "a") as f:
        f.write(message + "\n")

def calculate_hashes(file_path):
    """Calculate MD5, SHA1, and SHA256 hashes of the file."""
    hash_md5 = hashlib.md5()
    hash_sha1 = hashlib.sha1()
    hash_sha256 = hashlib.sha256()
    with open(file_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
            hash_sha1.update(chunk)
            hash_sha256.update(chunk)
    return hash_md5.hexdigest(), hash_sha1.hexdigest(), hash_sha256.hexdigest()

def static_analysis(file_path):
    """Perform static analysis on the malware sample."""
    log_to_file("[+] Starting static analysis...")
    
    # Calculate hashes
    md5, sha1, sha256 = calculate_hashes(file_path)
    log_to_file(f"MD5: {md5}")
    log_to_file(f"SHA1: {sha1}")
    log_to_file(f"SHA256: {sha256}")
    
    # Check with VirusTotal
    log_to_file("[+] Checking file reputation with VirusTotal...")
    url = "https://www.virustotal.com/api/v3/files/" + sha256
    headers = {"x-apikey": VIRUSTOTAL_API_KEY}
    response = requests.get(url, headers=headers)
    if response.status_code == 200:
        data = response.json()
        stats = data['data']['attributes']['last_analysis_stats']
        log_to_file(f"VirusTotal Detection: {stats['malicious']}/{stats['total']} engines flagged as malicious")
    else:
        log_to_file("VirusTotal check failed.")
    
    # Analyze PE headers (for Windows executables)
    try:
        pe = pefile.PE(file_path)
        log_to_file(f"Entry Point: {hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint)}")
        log_to_file(f"Number of Sections: {len(pe.sections)}")
        for section in pe.sections:
            log_to_file(f"Section: {section.Name.decode().strip()}, Virtual Address: {hex(section.VirtualAddress)}")
    except Exception as e:
        log_to_file(f"PE analysis failed: {str(e)}")
    
    # YARA rule matching
    log_to_file("[+] Scanning with YARA rules...")
    rules = yara.compile(YARA_RULES_PATH)
    matches = rules.match(file_path)
    if matches:
        log_to_file("YARA Matches:")
        for match in matches:
            log_to_file(f"- {match.rule}")
    else:
        log_to_file("No YARA matches found.")
    
    log_to_file("[+] Static analysis complete.\n")

def network_monitor(runtime):
    """Capture and log network packets for the specified runtime."""
    log_to_file("[+] Starting network monitoring...")
    packets = sniff(timeout=runtime)  # Capture packets for the specified duration
    for packet in packets:
        if IP in packet:
            src_ip = packet[IP].src
            dst_ip = packet[IP].dst
            proto = packet[IP].proto
            if proto == 6 and TCP in packet:  # TCP
                log_to_file(f"TCP {src_ip}:{packet[TCP].sport} -> {dst_ip}:{packet[TCP].dport}")
            elif proto == 17 and UDP in packet:  # UDP
                log_to_file(f"UDP {src_ip}:{packet[UDP].sport} -> {dst_ip}:{packet[UDP].dport}")
    log_to_file("[+] Network monitoring complete.\n")

class FileChangeHandler(FileSystemEventHandler):
    """Log file system changes."""
    def on_any_event(self, event):
        log_to_file(f"File system event: {event.event_type} - {event.src_path}")

def file_system_monitor(directory, runtime):
    """Monitor file system changes in the specified directory."""
    log_to_file("[+] Starting file system monitoring...")
    event_handler = FileChangeHandler()
    observer = Observer()
    observer.schedule(event_handler, directory, recursive=True)
    observer.start()
    time.sleep(runtime)  # Monitor for the specified duration
    observer.stop()
    observer.join()
    log_to_file("[+] File system monitoring complete.\n")

def on_message(message, data):
    """Log messages from Frida script."""
    if message['type'] == 'send':
        log_to_file(f"API Call: {message['payload']}")

def api_call_monitor(pid, runtime):
    """Monitor API calls using Frida for the specified runtime."""
    log_to_file("[+] Starting API call monitoring with Frida...")
    try:
        session = frida.attach(pid)
        script = session.create_script("""
            Interceptor.attach(Module.findExportByName(null, 'CreateFileW'), {
                onEnter: function(args) {
                    send('CreateFileW: ' + args[0].readUtf16String());
                }
            });
            Interceptor.attach(Module.findExportByName(null, 'InternetOpenW'), {
                onEnter: function(args) {
                    send('InternetOpenW: ' + args[0].readUtf16String());
                }
            });
            // Add more API hooks here (e.g., RegCreateKey, WriteProcessMemory)
        """)
        script.on('message', on_message)
        script.load()
        time.sleep(runtime)  # Monitor for the specified duration
        session.detach()
    except Exception as e:
        log_to_file(f"Frida monitoring failed: {str(e)}")
    log_to_file("[+] API call monitoring complete.\n")

def monitor_process(pid):
    """Monitor process behavior (CPU, memory, network)."""
    process = psutil.Process(pid)
    while True:
        try:
            cpu_usage = process.cpu_percent(interval=1)
            memory_usage = process.memory_info().rss / (1024 * 1024)  # in MB
            log_to_file(f"Process {pid}: CPU {cpu_usage}%, Memory {memory_usage} MB")
            time.sleep(5)
        except psutil.NoSuchProcess:
            break

def dynamic_analysis(file_path, runtime=60):
    """Perform dynamic analysis by executing the malware in a controlled environment."""
    log_to_file("[+] Starting dynamic analysis...")
    
    try:
        process = subprocess.Popen(file_path, shell=True)
        log_to_file(f"Malware executed with PID: {process.pid}")
        
        # Start monitoring threads
        monitor_thread = threading.Thread(target=monitor_process, args=(process.pid,))
        network_thread = threading.Thread(target=network_monitor, args=(runtime,))
        fs_thread = threading.Thread(target=file_system_monitor, args=(os.path.dirname(file_path), runtime))
        api_thread = threading.Thread(target=api_call_monitor, args=(process.pid, runtime))
        
        monitor_thread.start()
        network_thread.start()
        fs_thread.start()
        api_thread.start()
        
        # Wait for the specified runtime
        time.sleep(runtime)
        
        # Terminate the process
        process.terminate()
        log_to_file("Malware process terminated.")
        
        # Join threads
        monitor_thread.join()
        network_thread.join()
        fs_thread.join()
        api_thread.join()
    except Exception as e:
        log_to_file(f"Dynamic analysis failed: {str(e)}")
    
    log_to_file("[+] Dynamic analysis complete.\n")

def main():
    """Main function to run the malware analysis."""
    parser = argparse.ArgumentParser(description="Advanced Malware Analysis Script")
    parser.add_argument("file_path", help="Path to the malware executable")
    parser.add_argument("--runtime", type=int, default=60, help="Runtime in seconds for dynamic analysis")
    args = parser.parse_args()
    
    log_to_file("=== Malware Analysis Report ===")
    log_to_file(f"Sample: {args.file_path}")
    log_to_file(f"Analysis Date: {time.ctime()}\n")
    
    static_analysis(args.file_path)
    dynamic_analysis(args.file_path, args.runtime)
    
    log_to_file("=== End of Report ===")

if __name__ == "__main__":
    main()
